// NSLib memory internal header
#pragma once
#ifndef _XNSMEM0_
#define _XNSMEM0_

#include <xnsdef>

#include <stdio.h>

// will eventually use custom heap but not while testing other parts of the library
// #define NS_USE_CUSTOM_HEAP
// #define NS_DEBUG

#ifndef _NSHEAP_
#pragma pack(push, 1)
#endif

_NSTD_BEGIN

// making a heap is a headache
#ifndef _NSHEAP_
#define _NSHEAP_CAP 32000
#define _NSHEAP_CHUNKS_CAP 1000

struct _Heap_chunk
    {
    size_t _Size;
    void * _Ptr;
    };

char _Heap[_NSHEAP_CAP] = {0};
void * _Heapptr = _Heap;
_Heap_chunk _Heap_chunks[_NSHEAP_CHUNKS_CAP];
size_t _Heap_size = 0;
size_t _Heap_chunks_size = 0;

#define _NSHEAP_
#pragma pack(pop)
#endif // _NSHEAP_

#ifndef NS_DEBUG
void * nsmalloc(const size_t _Size)
    {
    return ::operator new(_Size);
    }

void nsfree(void * _Ptr, const size_t _Size)
    {
    ::operator delete(_Ptr, _Size);
    }

void nsfree(void * _Ptr)
    {
    ::operator delete(_Ptr);
    }
#else
void * nsmalloc(const size_t _Size)
    {
    if (_Size + _Heap_size >= _NSHEAP_CAP)
        {
        return nullptr;
        }

    if (_Heap_chunks_size + 1 >= _NSHEAP_CHUNKS_CAP)
        {
        return nullptr;
        }

    void * _Myptr = &_Heap + _Heap_size;
    void * _Heapptr = _Heap;
    printf("ptr in array: %i", ((int *)_Myptr - (int *)_Heapptr));
    _Heap_chunk _Chunk = {_Size, _Myptr};

    _Heap_size += _Size;
    printf("heap size: %i\n", _Heap_size);
    _Heap_chunks[_Heap_chunks_size++] = _Chunk;

    return _Myptr;
    }

void nsfree(void * _Ptr, const size_t _Size)
    {
    }

void nsfree(void * _Ptr)
    {
    }
#endif // _NS_DEBUG

        // CLASS TEMPLATE _NSTD_allocator_traits
template<class _Ty>
    class _NSTD_allocator_traits
    { // allocator traits using nslib heap
private:

    _NSTD_allocator_traits()
        {
        }

public:

    static void * _Allocate(const size_t _Size)
        {
        return nsmalloc(_Size * sizeof(_Ty));
        }

    static void _Deallocate(void * _Ptr, const size_t _Size)
        {
        nsfree(_Ptr, _Size * sizeof(_Ty));
        }

    };

        // CLASS TEMPLATE _STD_allocator_traits
template<class _Ty>
    class _STD_allocator_traits
    { // allocator traits using builtins
private:

    _STD_allocator_traits()
        {
        }

public:

    static void * _Allocate(const size_t _Size)
        {
        return ::operator new(_Size * sizeof(_Ty));
        }

    static void _Deallocate(void * _Ptr, const size_t _Size)
        {
        ::operator delete(_Ptr, _Size * sizeof(_Ty));
        }

    };

#ifndef NS_USE_CUSTOM_HEAP
template<class _Ty>
using _Default_allocator_traits = _STD_allocator_traits<_Ty>;
#else
template<class _Ty>
using _Default_allocator_traits = _NSTD_allocator_traits<_Ty>;
#endif

        // CLASS TEMPLATE allocator
template<class _Ty,
    class _Traits = _Default_allocator_traits<_Ty>>
    class allocator
    { // generic allocator for objects of class _Ty
public:
	using value_type = _Ty;
	using pointer = value_type *;
	using size_type = size_t;

    allocator()
        {
        }

    ~allocator()
        {
        }

    pointer allocate(const size_type _Count) const
        {
        pointer _Array = (pointer)_Traits::_Allocate(_Count);
        return _Array;
        }

    void deallocate(pointer _Ptr, const size_type _Count) const
        {
        _Traits::_Deallocate(_Ptr, _Count);
        }

    };

_NSTD_END

#endif // _XNSMEM0_

/*
 * Copyright (c) by R. Wilson. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V2.0:0002 */
