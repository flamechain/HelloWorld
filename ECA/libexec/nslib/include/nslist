// NSlib list header
#pragma once
#ifndef _NSLIST_
#define _NSLIST_

#include <xnsdef>
#include <xnsinit_list>
#include <xnsmem0>

using _NSTD allocator;
using _NSTD initializer_list;

        // STRUCT TEMPLATE _List_node
template<class _Ty>
    struct _List_node
    { // list node
    _List_node * _Prev;
    _Ty _Val;
    _List_node * _Next;
    };

        // CLASS TEMPLATE _List_alloc
template<class _Ty,
    class _Alloc = allocator<_Ty>>
    class _List_alloc
    { // base class for list to hold allocator
public:
    using _Node = struct _List_node<_Ty>;
    using _Nodeptr = struct _List_node<_Ty> *;
    using _Alty = _Alloc;

    using value_type = _Ty;
    using size_type = _NSTD size_t;
    using pointer = _Ty *;
    using const_pointer = const _Ty * const;

private:
    _Alty _AL;

public:

    _List_alloc() noexcept
        {
        this->_AL = _Alloc();
        }

    _List_alloc(const _Alty& _Al) noexcept
        {
        this->_AL = _Al;
        }

    ~_List_alloc()
        {
        }

    void _Moveal(const _Alty& _Al)
        {
        this->_AL = _Al;
        }

    _Alty _Getal() const
        {
        return this->_AL;
        }
    };

        // CLASS TEMPLATE list
template<class _Ty,
    class _Alloc = allocator<_Ty>>
    class list
        : _List_alloc<_Ty, _Alloc>
    { // bidirectional linked list
private:
    using _Mybase = _List_alloc<_Ty, _Alloc>;
    using _Nodeptr = typename _Mybase::_Nodeptr;
    using _Alty = typename _Mybase::_Alty;

    using value_type = typename _Mybase::value_type;
    using size_type = typename _Mybase::size_type;
    using pointer = typename _Mybase::pointer;
    using const_pointer = typename _Mybase::const_pointer;
    using node_type = typename _Mybase::_Node;
    using reference = value_type&;
    using const_reference = const value_type&;


    size_type _MY_SIZE;
    node_type _FIRST;
    node_type _LAST;

public:

    list() noexcept
        : _Mybase()
        {
        }

    list(initializer_list<value_type> _Ilist) noexcept
        : _Mybase()
        {
        this->_Construct_contents(_Ilist.begin(), _Ilist.size());
        }

    list(initializer_list<value_type> _Ilist, const _Alty& _Al) noexcept
        : _Mybase(_Al)
        {
        this->_Construct_contents(_Ilist.begin(), _Ilist.size());
        }

    list(const list& _Right) noexcept
        : _Mybase()
        {
        this->_Construct_contents(_Right._Myfirst(), _Right._Mysize());
        }

    list(const list& _Right, const _Alty& _Al) noexcept
        : _Mybase(_Al)
        {
        this->_Construct_contents(_Right._Myfirst(), _Right._Mysize());
        }

    explicit list(const _Alty& _Al) noexcept
        : _Mybase(_Al)
        {
        }

    ~list()
        {
        }

// "private" (only used by vector even if another instance)

// access methods

    size_type _Mysize() const
        {
        return this->_MY_SIZE;
        }

    node_type _Myfirst() const
        {
        return this->_MY_FIRST;
        }

    node_type _Mylast() const
        {
        return this->_MY_LAST;
        }

// operators

// public methods

    void insert(const_reference _Val, size_type _Index)
        {
        }

    const_pointer to_array() const
        {
        const_pointer _Array = {};
        return _Array;
        }

    size_type size() const
        {
        return this->_Mysize();
        }

    };

#endif // _NSLIST_

/*
 * Copyright (c) by R. Wilson. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V1.0:0002 */
