#pragma once
#ifndef _NSSTRING_
#define _NSSTRING_

// #include "nsvector"
#include <xnsmem0>

template<class _Elem,
    class _Alloc = allocator<_Elem>>
    class basic_string
    {
public:
    using value_type = typename _Alloc::value_type;
    using size_type = typename _Alloc::size_type;
    using pointer = typename _Alloc::pointer;
    using const_pointer = typename _Alloc::const_pointer;

private:
    pointer _MY_PTR = nullptr;
    size_type _MY_SIZE = 0;
    size_type _MY_RES = 0;
    _Alloc _Al;

public:

    basic_string(const basic_string& _Right)
        {
        const size_type _Right_size = _Right._Mysize();
        const _Elem * const _Right_ptr = _Right._Myptr(); // pointer type is not const
        const size_type _Right_res = _Right._Myres();

        this->_Construct_contents(_Right_ptr, _Right_size, _Right_res);
        }

    basic_string()
        {
        this->_Tidy_init();
        }

    basic_string(const_pointer _Right)
        {
        size_type _Right_strterm;

        for (_Right_strterm=0; ; _Right_strterm++)
            {
            if (_Right[_Right_strterm] == '\00')
                {
                break;
                }
            }

        const size_type _Right_size = _Right_strterm;
        const _Elem * const _Right_ptr = _Right;
        const size_type _Right_res = _Right_size;

        this->_Construct_contents(_Right_ptr, _Right_size, _Right_res);
        }

    basic_string(const_pointer _Right, const size_type _Size)
        {
        const _Elem * const _Right_ptr = _Right;

        this->_Construct_contents(_Right_ptr, _Size, _Size);
        }

    explicit basic_string(pointer _Right)
        {
        size_type _Right_strterm;

        for (_Right_strterm=0; ; _Right_strterm++)
            {
            if (_Right[_Right_strterm] == '\00')
                {
                break;
                }
            }

        pointer _New_ptr = this->_Al.allocate(_Right_strterm);

        for (int i=0; i<_Right_strterm; i++)
            {
            _New_ptr[i] = _Right[i];
            }

        _New_ptr[_Right_strterm] = '\00';

        const size_type _Right_size = _Right_strterm;
        const _Elem * const _Right_ptr = _New_ptr;
        const size_type _Right_res = _Right_size;

        this->_Construct_contents(_Right_ptr, _Right_size, _Right_res);
        }

    explicit basic_string(pointer _Right, const size_type _Size)
        {
        pointer _New_ptr = this->_Al.allocate(_Size);

        for (int i=0; i<_Size; i++)
            {
            _New_ptr[i] = _Right[i];
            }

        _New_ptr[_Size] = '\00';

        const _Elem * const _Right_ptr = _New_ptr;

        this->_Construct_contents(_Right_ptr, _Size, _Size);
        }

    explicit basic_string(value_type _Right)
        {
        pointer _New_ptr = this->_Al.allocate(1);
        _New_ptr[0] = _Right;

        const size_type _Right_size = 1;
        const _Elem * const _Right_ptr = _New_ptr;
        const size_type _Right_res = 1;

        this->_Construct_contents(_Right_ptr, _Right_size, _Right_res);
        }

    void _Construct_contents(const_pointer _Right_ptr, const size_type _Right_size, const size_type _Right_res)
        {
        if (_Right_size < this->_Myres())
            {
            this->copy(_Right_ptr, _Right_size);
            this->_MY_SIZE = _Right_size;
            return;
            }

        const size_type _New_capacity = _Right_size;
        const pointer _New_array = this->_Al.allocate(_Right_size);
        this->copy(_Right_ptr, _New_capacity, _New_array);
        this->_MY_SIZE = _Right_size;
        this->_MY_RES = _Right_res;
        }

    void copy(const_pointer _Array, size_type _Capacity)
        {
        for (int i=0; i<_Capacity; i++)
            {
            this->_MY_PTR[i] = _Array[i];
            }
        }

    void copy(const_pointer _Array, size_type _Capacity, const pointer _New_array)
        {
        this->_Al.deallocate(this->_Myptr());
        this->_MY_PTR = _New_array;
        this->copy(_Array, _Capacity);
        }

    void _Tidy_init()
        {
        this->_MY_SIZE = 0;
        this->_MY_RES = 0;
        this->_MY_PTR = nullptr;
        }

    _Alloc _Getal() const
        {
        return this->_Al;
        }

    const pointer _Myptr() const
        {
        return this->_MY_PTR;
        }

    size_type _Mysize() const
        {
        return this->_MY_SIZE;
        }

    size_type _Myres() const
        {
        return this->_MY_RES;
        }

    const_pointer c_str() const
        {
        pointer _New_ptr = this->_Al.allocate(this->_Mysize());

        for (int i=0; i<this->_Mysize(); i++)
            {
            _New_ptr[i] = this->_Myptr()[i];
            }

        _New_ptr[this->_Mysize()] = '\00';

        const_pointer _New_const_ptr = _New_ptr;
        return _New_const_ptr;
        }

    size_type length() const
        {
        return this->_Mysize();
        }



// seperate operators from other functions

    value_type operator[](size_type _Index) const
        {
        return this->_Myptr()[_Index];
        }
    };

using string = basic_string<char, allocator<char>>;

#endif
