#pragma once
#ifndef _NSSTRING_
#define _NSSTRING_

#include <stdio.h> // temp, for debugging
#include <xnsmem0>

template<class _Elem,
    class _Alloc = allocator<_Elem>>
    class basic_string
    {
public:
    using value_type = typename _Alloc::value_type;
    using size_type = typename _Alloc::size_type;
    using pointer = typename _Alloc::pointer;
    using const_pointer = typename _Alloc::const_pointer;

private:
    pointer _MY_PTR = nullptr;
    size_type _MY_SIZE = 0;
    size_type _MY_RES = 0;
    _Alloc _Al;

public:

    basic_string(const basic_string& _Right)
        {
        const size_type _Right_size = _Right._Mysize();
        const _Elem * const _Right_ptr = _Right._Myptr(); // pointer type is not const
        const size_type _Right_res = _Right._Myres();

        this->_Construct_contents(_Right_ptr, _Right_size, _Right_res);
        }

    basic_string()
        {
        this->_Tidy_init();
        }

    basic_string(const_pointer _Right)
        {
        const size_type _Right_size = this->_Get_pointer_size(_Right);
        const _Elem * const _Right_ptr = _Right;
        const size_type _Right_res = _Right_size;

        this->_Construct_contents(_Right_ptr, _Right_size, _Right_res);
        }

    basic_string(const_pointer _Right, const size_type _Size)
        {
        const _Elem * const _Right_ptr = _Right;

        this->_Construct_contents(_Right_ptr, _Size, _Size);
        }

    explicit basic_string(pointer _Right)
        {
        const size_type _Right_size = this->_Get_pointer_size(_Right);
        pointer _New_ptr = this->_Al.allocate(_Right_size);

        for (int i=0; i<_Right_size; i++)
            {
            _New_ptr[i] = _Right[i];
            }

        _New_ptr[_Right_size] = '\00';

        const _Elem * const _Right_ptr = _New_ptr;
        const size_type _Right_res = _Right_size;

        this->_Construct_contents(_Right_ptr, _Right_size, _Right_res);
        }

    explicit basic_string(pointer _Right, const size_type _Size)
        {
        pointer _New_ptr = this->_Al.allocate(_Size);

        for (int i=0; i<_Size; i++)
            {
            _New_ptr[i] = _Right[i];
            }

        _New_ptr[_Size] = '\00';

        const _Elem * const _Right_ptr = _New_ptr;

        this->_Construct_contents(_Right_ptr, _Size, _Size);
        }

    explicit basic_string(value_type _Right)
        {
        pointer _New_ptr = this->_Al.allocate(1);
        _New_ptr[0] = _Right;

        const size_type _Right_size = 1;
        const _Elem * const _Right_ptr = _New_ptr;
        const size_type _Right_res = 1;

        this->_Construct_contents(_Right_ptr, _Right_size, _Right_res);
        }

    // not in operator sections because these are treated as re-init-constructors
    void operator=(const basic_string& _Right)
        {
        this->_Reset();

        const size_type _Right_size = _Right._Mysize();
        const size_type _Right_res = _Right._Myres();
        const _Elem * const _Right_ptr = _Right._Myptr();

        this->_Construct_contents(_Right_ptr, _Right_size, _Right_res);
        }

    void operator=(const_pointer _Right)
        {
        this->_Reset();

        const size_type _Right_size = this->_Get_pointer_size(_Right);

        this->_Construct_contents(_Right, _Right_size, _Right_size);
        }

    void operator=(value_type _Right)
        {
        this->_Reset();
        pointer _Right_new = this->_Al.allocate(2);
        _Right_new[0] = _Right;
        _Right_new[1] = '\00';

        const size_type _Right_size = _Right._Mysize();
        const size_type _Right_res = _Right._Myres();
        const _Elem * const _Right_ptr = _Right_new;

        this->_Construct_contents(_Right_ptr, _Right_size, _Right_res);
        }

    void _Reset()
        {
        this->_Al.deallocate(this->_MY_PTR);
        this->_Tidy_init();
        }

    void _Construct_contents(const_pointer _Right_ptr, const size_type _Right_size, const size_type _Right_res)
        {
        if (_Right_size < this->_Myres())
            {
            this->copy(_Right_ptr, _Right_size);
            this->_MY_SIZE = _Right_size;
            return;
            }

        const size_type _New_capacity = _Right_size;
        pointer _New_array = this->_Al.allocate(_Right_size);
        this->copy(_Right_ptr, _New_capacity, _New_array);
        this->_MY_SIZE = _Right_size;
        this->_MY_RES = _Right_res;
        }

    void copy(const_pointer _Array, size_type _Capacity)
        {
        for (int i=0; i<_Capacity; i++)
            {
            this->_MY_PTR[i] = _Array[i];
            }
        }

    void copy(const_pointer _Array, size_type _Capacity, pointer _New_array)
        {
        this->_Al.deallocate(this->_MY_PTR);
        this->_MY_PTR = _New_array;
        this->copy(_Array, _Capacity);
        }

    void _Tidy_init()
        {
        this->_MY_SIZE = 0;
        this->_MY_RES = 0;
        this->_MY_PTR = nullptr;
        }

    _Alloc _Getal() const
        {
        return this->_Al;
        }

    pointer _Myptr() const
        {
        return this->_MY_PTR;
        }

    size_type _Mysize() const
        {
        return this->_MY_SIZE;
        }

    size_type _Myres() const
        {
        return this->_MY_RES;
        }

    size_type _Get_pointer_size(const_pointer _Ptr)
        {
        size_type _Ptr_strterm;

        for (_Ptr_strterm=0; ; _Ptr_strterm++)
            {
            if (_Ptr[_Ptr_strterm] == '\00')
                {
                break;
                }
            }

        return _Ptr_strterm;
        }

    size_type _Get_pointer_size(pointer _Ptr)
        {
        const_pointer _New_ptr = _Ptr;
        return this->_Get_pointer_size(_New_ptr);
        }

    int _Compare_pointer_values(pointer _Left, pointer _Right)
        {
        const size_type _Left_size = this->_Get_pointer_size(_Left);
        const size_type _Right_size = this->_Get_pointer_size(_Right);

        if (_Left_size != _Right_size)
            {
            return 0;
            }

        for (int i=0; i<_Left_size; i++)
            {
            if (_Left[i] != _Right[i])
                {
                return 0;
                }
            }

        return 1;
        }

    basic_string * _Increase_array_alloc(basic_string * _Array, size_type _Size, size_type _Count)
        {
        basic_string * _New_seg = new basic_string[_Size+_Count];

        for (int i=0; i<_Size; i++)
            {
            _New_seg[i] = _Array[i];
            }

        delete[] _Array; // may cause issues
        return _New_seg;
        }

    void _Copy_into(pointer _Left, pointer _Right)
        {
        const size_type _Right_size = this->_Get_pointer_size(_Right);

        for (int i=0; i<_Right_size; i++)
            {
            _Left[i] - _Right[i];
            }
        }

    pointer _Get_pointer_copy(const_pointer _Ptr)
        {
        const size_type _Ptr_size = this->_Get_pointer_size(_Ptr);
        pointer _Copy = this->_Al.allocate(_Ptr_size);

        for (int i=0; i<_Ptr_size; i++)
            {
            _Copy[i] = _Ptr[i];
            }

        _Copy[_Ptr_size] = '\00';
        return _Copy;
        }

    pointer _Add_two_pointers(pointer _Left, const_pointer _Right)
        {
        return this->_Add_two_pointers(_Left, this->_Get_pointer_copy(_Right));
        }

    pointer _Add_two_pointers(pointer _Left, pointer _Right)
        {
        const size_type _Left_size = this->_Get_pointer_size(_Left);
        const size_type _Left_res = _Left_size;
        const size_type _Right_size = this->_Get_pointer_size(_Right);
        const size_type _Right_res = _Right_size;
        const size_type _New_capacity = _Left_size + _Right_size;

        pointer _Combined = this->_Al.allocate(_New_capacity);

        for (int i=0; i<_Left_size; i++)
            {
            _Combined[i] = _Left[i];
            }

        for (int i=0; i<_Right_size; i++)
            {
            _Combined[_Left_size+i] = _Right[i];
            }

        _Combined[_New_capacity] = '\00';

        return _Combined;
        }

// operators

    int operator==(const basic_string& _Right)
        {
        if (this->_Compare_pointer_values(this->_Myptr(), _Right._Myptr()))
            {
            return 1;
            }

        return 0;
        }

    int operator==(const_pointer _Right)
        {
        if (this->_Compare_pointer_values(this->_Myptr(), _Right))
            {
            return 0;
            }

        return 1;
        }

    int operator==(value_type _Right)
        {
        if (this->_Mysize() == 1) // nested prevents error if _MY_SIZE = 0
            {
            if (this->_Myptr()[0] == _Right)
                {
                return 1;
                }
            }

        return 0;
        }

    int operator!=(const basic_string& _Right)
        {
        if (this->_Compare_pointer_values(this->_Myptr(), _Right._Myptr()))
            {
            return 0;
            }

        return 1;
        }

    int operator!=(const_pointer _Right)
        {
        if (this->_Compare_pointer_values(this->_Myptr(), _Right))
            {
            return 0;
            }

        return 1;
        }

    int operator!=(value_type _Right)
        {
        if (this->_Mysize() == 1) // nested prevents error if _MY_SIZE = 0
            {
            if (this->_Myptr()[0] == _Right)
                {
                return 0;
                }
            }

        return 1;
        }

    void operator+=(const basic_string& _Right)
        {
        const size_type _Right_size = _Right._Mysize();
        const size_type _Right_res = _Right._Myres();
        const _Elem * const _Right_ptr = _Right._Myptr();

        if (this->_Myres() >= this->_Mysize() + _Right_size)
            {
            for (int i=0; i<_Right_size; i++)
                {
                this->_Myptr()[this->_Mysize()+i] = _Right_ptr[i];
                }

            this->_MY_SIZE += _Right_size;
            this->_Myptr()[this->_Mysize()] = '\00';
            return;
            }

        const size_type _New_capacity = this->_Mysize()+_Right_size;
        pointer _New_array = this->_Al.allocate(_New_capacity);
        _New_array = this->_Add_two_pointers(this->_Myptr(), _Right_ptr);

        this->_Al.deallocate(this->_MY_PTR);
        this->_MY_PTR = _New_array;
        this->_MY_SIZE = _New_capacity;
        this->_MY_RES = _New_capacity;
        }

    void operator+=(const_pointer _Right)
        {
        const size_type _Right_size = this->_Get_pointer_size(_Right);
        const size_type _Right_res = _Right_size;

        if (this->_Myres() >= this->_Mysize() + _Right_size)
            {
            for (int i=0; i<_Right_size; i++)
                {
                this->_Myptr()[this->_Mysize()+i] = _Right[i];
                }

            this->_MY_SIZE += _Right_size;
            this->_Myptr()[this->_Mysize()] = '\00';
            return;
            }

        const size_type _New_capacity = this->_Mysize()+_Right_size;
        pointer _New_array = this->_Al.allocate(_New_capacity);
        _New_array = this->_Add_two_pointers(this->_Myptr(), _Right);

        this->_Al.deallocate(this->_MY_PTR);
        this->_MY_PTR = _New_array;
        this->_MY_SIZE = _New_capacity;
        this->_MY_RES = _New_capacity;
        }

    void operator+=(value_type _Right)
        {
        if (this->_Myres() >= this->_Mysize() + 1)
            {
            this->_Myptr()[this->_Mysize()] = _Right;
            this->_Myptr()[this->_Mysize()+1] = '\00';
            return;
            }

        const size_type _New_capacity = this->_Mysize()+1;
        pointer _New_array = this->_Al.allocate(_New_capacity);
        this->_MY_SIZE = this->_Mysize() + 1;
        this->_MY_RES = this->_Mysize() + 1;

        for (int i=0; i<_New_capacity-1; i++)
            {
            _New_array[i] = this->_Myptr()[i];
            }

        _New_array[_New_capacity-1] = _Right;
        _New_array[_New_capacity] = '\00';

        this->_Al.deallocate(this->_MY_PTR);
        this->_MY_PTR = _New_array;
        }

    pointer operator+(const basic_string& _Right)
        {
        pointer _Copy = this->_Al.allocate(this->_Mysize() + _Right._Mysize());

        _Copy = this->_Add_two_pointers(this->_Myptr(), _Right._Myptr());
        return _Copy;
        }

    pointer operator+(const_pointer _Right)
        {
        const size_type _Right_size = this->_Get_pointer_size(_Right);
        pointer _Copy = this->_Al.allocate(this->_Mysize() + _Right_size);

        _Copy = this->_Add_two_pointers(this->_Myptr(), _Right);
        return _Copy;
        }

    pointer operator+(value_type _Right)
        {
        pointer _Copy = this->_Al.allocate(this->_Mysize() + 1);
        pointer _Right_ptr = this->_Al.allocate(2);

        _Right_ptr[0] = _Right;
        _Right_ptr[1] = '\00';

        _Copy = this->_Add_two_pointers(this->_Myptr(), _Right_ptr);
        return _Copy;
        }

    value_type operator[](size_type _Index) const
        {
        return this->_Myptr()[_Index];
        }

// external methods

    const_pointer c_str() const
        {
        pointer _New_ptr = this->_Al.allocate(this->_Mysize());

        for (int i=0; i<this->_Mysize(); i++)
            {
            _New_ptr[i] = this->_Myptr()[i];
            }

        _New_ptr[this->_Mysize()] = '\00';

        const_pointer _New_const_ptr = _New_ptr;
        return _New_const_ptr;
        }

    size_type length() const
        {
        return this->_Mysize();
        }

    int startswith(const basic_string& _Sub)
        {
        return this->startswith(_Sub.c_str()); // bad practice, but prevents duplicate code / uneccessary abstraction functions
        }

    int startswith(const_pointer _Sub)
        {
        const size_type _Sub_size = this->_Get_pointer_size(_Sub);

        if (this->_Mysize() < _Sub_size)
            {
            return 0;
            }

        for (int i=0; i<this->_Mysize(); i++)
            {
            if (i < _Sub_size)
                {
                if (this->_Myptr()[i] != _Sub[i])
                    {
                    return 0;
                    }
                }
            }

        return 1;
        }

    int startswith(value_type _Sub)
        {
        if (this->_Mysize() > 0)
            {
            if (this->_Myptr()[0] == _Sub)
                {
                return 1;
                }
            }

        return 0;
        }

    int endswith(const basic_string& _Sub)
        {
        return this->endswith(_Sub.c_str());
        }

    int endswith(const_pointer _Sub)
        {
        const size_type _Sub_size = this->_Get_pointer_size(_Sub);

        if (this->_Mysize() < _Sub_size)
            {
            return 0;
            }

        for (int i=this->_Mysize()-_Sub_size; i<this->_Mysize(); i++)
            {
            if (this->_Myptr()[i] != _Sub[i-this->_Mysize()+_Sub_size])
                {
                return 0;
                }
            }

        return 1;
        }

    int endswith(value_type _Sub)
        {
        if (this->_Mysize() > 0)
            {
            if (this->_Myptr()[this->_Mysize()-1] == _Sub)
                {
                return 1;
                }
            }

        return 0;
        }

    basic_string substring(size_type _Start)
        {
        return this->substring(_Start, this->_Mysize()-1);
        }

    basic_string substring(size_type _Start, size_type _End)
        {
        pointer _Substring = this->_Al.allocate(_End-_Start+1);

        if (this->_Mysize() <= _Start)
            {
            return _Substring; // "null"
            }

        for (int i=_Start; i<=_End; i++) // inclusive (i<_End for exclusive)
            {
            _Substring[i-_Start] = this->_Myptr()[i];
            }

        _Substring[_End+1] = '\00';
        return basic_string(_Substring);
        }

    int contains(const basic_string& _Sub)
        {
        return this->contains(_Sub.c_str());
        }

    int contains(const_pointer _Sub)
        {
        const size_type _Sub_size = this->_Get_pointer_size(_Sub);

        if (this->_Mysize() < _Sub_size)
            {
            return 0;
            }

        for (int i=0; i<this->_Mysize(); i++)
            {
            if (this->substring(i).startswith(_Sub))
                {
                return 1;
                }
        // old way is too complex, maybe faster should test
            // if (this->_Myptr()[i] == _Sub[0]) // faster to only call compare if first char is same
            //     {
            //     pointer _Sub_n = this->_Get_pointer_copy(_Sub);
            //     pointer _Smaller = this->_Get_pointer_copy(this->substring(i, i+_Sub_size-1).c_str());

            //     // could also use startswith here
            //     if (this->_Compare_pointer_values(_Sub_n, _Smaller))
            //         {
            //         return 1;
            //         }
            //     }
            }

        return 0;
        }

    int contains(value_type _Sub)
        {
        if (this->_Mysize() == 0)
            {
            return 0;
            }

        for (int i=0; i<this->_Mysize(); i++)
            {
            if (this->_Myptr()[i] == _Sub)
                {
                return 1;
                }
            }

        return 0;
        }

    basic_string * split(const basic_string& _Delim, size_type * _Count)
        {
        return this->split(_Delim.c_str(), _Count);
        }

    basic_string * split(const_pointer _Delim, size_type * _Count)
        {
        const size_type _Delim_size = this->_Get_pointer_size(_Delim);

        // this probably shouldn't use array of self or avoid using allocator
        size_type _Res = 10;
        size_type _Used = 0;
        basic_string * _Segments = new basic_string[_Res];

        _Count = 1;
        size_type _Cur_res = 10;
        size_type _Cur_used = 0;
        pointer _Current = this->_Al.allocate(_Cur_res);

        for (int i=0; i<this->_Mysize(); i++)
            {
            if (this->substring(i).startswith(_Delim))
                {
                _Count++;
                i += _Delim_size - 1;
                // basically vector
                if (_Used >= _Res)
                    {
                    _Res += 10;
                    _Segments = this->_Increase_array_alloc(_Segments, _Used, _Res);
                    }

                _Segments[_Used++] = basic_string(_Current);
                _Cur_used = 0;
                _Current[0] = '\00';
                continue; // better than else?
                }

            if (_Cur_used >= _Cur_res)
                {
                _Cur_res += 10;
                pointer _New_cur = this->_Al.allocate(_Cur_res);
                this->_Copy_into(_New_cur, _Current);
                this->_Al.deallocate(_Current);
                _Current = _New_cur;
                }

            _Current[_Cur_used++] = this->_Myptr()[i];
            }

        if (_Used >= _Res)
            {
            _Res += 10;
            _Segments = this->_Increase_array_alloc(_Segments, _Used, _Res);
            }

        _Segments[_Used++] = _Current;

        return _Segments;
        }

    basic_string * split(value_type _Delim, size_type * _Count)
        {
        pointer _S_delim = this->_Al.allocate(2);
        _S_delim[0] = _Delim;
        _S_delim[1] = '\00';
        const_pointer _Const_delim = _S_delim;

        return this->split(_Const_delim, _Count);
        }

    basic_string * split(const basic_string& _Delim)
        {
        size_type * _Count;
        return this->split(_Delim, _Count);
        }

    basic_string * split(const_pointer _Delim)
        {
        size_type * _Count;
        return this->split(_Delim, _Count);
        }

    basic_string * split(value_type _Delim)
        {
        size_type * _Count;
        return this->split(_Delim, _Count);
        }

    // basic_string join(pointer * _Elems)
    //     {
    //     }

    };

using string = basic_string<char, allocator<char>>;

#endif
