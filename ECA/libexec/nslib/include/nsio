#pragma once
#ifndef _NSIO_
#define _NSIO_

#include <unistd.h>

#include <fstream>
#include <string>

#ifndef __has_include
  static_assert(false, "__has_include not supported");
#else
#  if __cplusplus >= 201703L && __has_include(<filesystem>)
#    include <filesystem>
    //  namespace fs = std::filesystem;
    using std::filesystem::current_path;
#  elif __has_include(<experimental/filesystem>)
#    include <experimental/filesystem>
    //  namespace fs = std::experimental::filesystem;
     using std::experimental::filesystem::current_path;
#  elif __has_include(<boost/filesystem.hpp>)
#    include <boost/filesystem.hpp>
    //  namespace fs = boost::filesystem;
     using boost::filesystem::current_path;
#  else
#    define _NO_FILESYSTEM_
#  endif
#endif

#include "nsvector"
#include "nsstring"

typedef unsigned char byte;
typedef unsigned short word;
typedef unsigned int dword;
typedef unsigned long long qword;

// static class for getting file data
    class file {
private:
    file() {}

public:
    static bool FileExists(string f) {
        std::ifstream file (f.c_str());

        if (file.is_open())
            {
            file.close();
            return true;
            }

        return false;
    }

    static int ReadAllText(string f, string *b) {
        string t = "";
        std::string ln;
        std::ifstream file (f.c_str());

        if (file.is_open())
            {
            while (std::getline(file, ln))
                {
                t += ln.c_str();
                t += "\n";
                }

            file.close();
            }
        else
            {
            return 1;
            }

        *b = t;
        return 0;
    }

    static string ReadAllText(string f) {
        string t = "";
        std::string ln;
        std::ifstream file (f.c_str());

        if (file.is_open())
            {
            while (std::getline(file, ln))
                {
                t += ln.c_str();
                t += "\n";
                }

            file.close();
            }

        return t;
    }

    static vector<string> ReadAllLines(string f) {
        vector<string> lns;
        std::string ln;
        std::ifstream file (f.c_str());

        if (file.is_open())
            {
            while (std::getline(file, ln))
                {
                lns.append((string)ln.c_str());
                }

            file.close();
            }

        return lns;
    }

    static vector<byte> ReadAllBytes(string f) {
        vector<byte> bs;
        char b;
        std::ifstream fin(f.c_str());

        if (fin.is_open())
            {
            while (fin.get(b))
                {
                bs.append((byte)b);
                }

            fin.close();
            }

        return bs;
    }

    static void WriteAllText(string f, string d) {
        std::ofstream fout (f.c_str(), std::ofstream::binary);
        printf("beforewrite\n");
        fout.write(d.c_str(), d.length());
        printf("afterwrite\n");
        fout.close();
    }

    static void WriteAllLines(string f, vector<string> d) {
        std::ofstream fout(f.c_str());
        string dt = "";

        for (int i=0; i<d.count(); i++)
            {
            dt += d[i];
            dt += '\n';
            }

        fout.write(dt.c_str(), dt.length());
        fout.close();
    }

    static void WriteAllBytes(string f, vector<byte> d) {
        std::ofstream fout(f.c_str(), std::ios::binary);
        fout.write((char*)d.toArray(), d.count());
        fout.close();
    }

    static string GetWorkingDir() {
#ifdef _NO_FILESYSTEM_
        char *tmp = (char*)malloc(256); // arbitrary
        getcwd(tmp, 256);
        return string(tmp);
#endif
#ifndef _NO_FILESYSTEM_
        std::string std_path = current_path().string();
        return string(std_path.c_str());
#endif
    }
};

#endif
