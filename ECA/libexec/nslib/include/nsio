// NSLib FileIO header
#pragma once
#ifndef _NSIO_
#define _NSIO_

#include <fstream>
#include <string>

#include <nsvector>
#include <nsstring>

#ifndef __has_include
  static_assert(false, "__has_include not supported");
#else
#  if __cplusplus >= 201703L && __has_include(<filesystem>)
#    include <filesystem>
    //  namespace fs = std::filesystem;
    using std::filesystem::current_path;
#  elif __has_include(<experimental/filesystem>)
#    include <experimental/filesystem>
    //  namespace fs = std::experimental::filesystem;
     using std::experimental::filesystem::current_path;
#  elif __has_include(<boost/filesystem.hpp>)
#    include <boost/filesystem.hpp>
    //  namespace fs = boost::filesystem;
     using boost::filesystem::current_path;
#  else
#    define _NO_FILESYSTEM_
#    include <unistd.h>
#  endif
#endif


    class file {
private:
    file()
        {
        }

public:
    static int FileExists(string _File)
        {
        std::ifstream _Filestream (_File.c_str());

        if (_Filestream.is_open())
            {
            _Filestream.close();
            return 1;
            }

        return 0;
    }

    static int ReadAllText(string _File, string * _Buf) {
        string _Text;
        std::string _Line_buf;
        std::ifstream _Filestream (_File.c_str());

        if (_Filestream.is_open())
            {
            while (std::getline(_Filestream, _Line_buf))
                {
                _Text += _Line_buf.c_str();
                _Text += "\n";
                }

            _Filestream.close();
            }
        else
            {
            return 1;
            }

        *_Buf = _Text;
        return 0;
    }

    static string ReadAllText(string _File) {
        string _Buf;
        ReadAllText(_File, &_Buf);
    }

    static vector<string> ReadAllLines(string _File) {
        vector<string> _Lines;
        std::string _Line_buf;
        std::ifstream _Filestream (_File.c_str());

        if (_Filestream.is_open())
            {
            while (std::getline(_Filestream, _Line_buf))
                {
                _Lines.append(string(_Line_buf.c_str()));
                }

            _Filestream.close();
            }

        return _Lines;
    }

    static vector<char> ReadAllBytes(string _File) {
        vector<char> _Bytes;
        char _Byte_buf;
        std::ifstream _Filestream (_File.c_str());

        if (_Filestream.is_open())
            {
            while (_Filestream.get(_Byte_buf))
                {
                _Bytes.append(_Byte_buf);
                }

            _Filestream.close();
            }

        return _Bytes;
    }

    static void WriteAllText(string _File, string _Text) {
        std::ofstream _Filestream (_File.c_str(), std::ofstream::binary);
        _Filestream.write(_Text.c_str(), _Text.length());
        _Filestream.close();
    }

    static void WriteAllLines(string _File, vector<string> _Lines) {
        std::ofstream _Filestream (_File.c_str());
        string _Text;

        for (int i=0; i<_Lines.count(); i++)
            {
            _Text += _Lines[i];
            _Text += '\n';
            }

        _Filestream.write(_Text.c_str(), _Text.length());
        _Filestream.close();
    }

    static void WriteAllBytes(string _File, vector<char> _Bytes) {
        std::ofstream _Filestream (_File.c_str(), std::ios::binary);
        _Filestream.write(_Bytes.to_array(), _Bytes.count());
        _Filestream.close();
    }

    static string GetWorkingDir() {
#ifdef _NO_FILESYSTEM_
        char *tmp = (char*)malloc(256); // arbitrary
        getcwd(tmp, 256);
        return string(tmp);
#else
        std::string std_path = current_path().string();
        return string(std_path.c_str());
#endif
    }
};

#endif
