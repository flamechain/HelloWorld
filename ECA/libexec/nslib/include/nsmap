// NSLib map header
#pragma once
#ifndef _NSMAP_
#define _NSMAP_

#include <xnsdef>
#include <xnsmem0>
#include <xnsinit_list>

using _NSTD allocator;
using _NSTD initializer_list;

        // CLASS TEMPLATE pair
template<class _Kty,
    class _Ty>
    class pair
    { // store a pair of values
private:
    using key_type = _Kty;
    using mapped_type = _Ty;

public:

    pair() noexcept
        {
        }

    pair(key_type _Key, mapped_type _Val) noexcept
        {
        }

    };

        // CLASS TEMPLATE make_pair
template<class _Kty,
    class _Ty>
    pair<_Kty, _Ty> make_pair(_Kty _Key, _Ty _Val)
        {
        pair<_Kty, _Ty> _Pair (_Key, _Val);
        return _Pair;
        }

        // CLASS TEMPLATE less
template<class _Ty>
    class less
    { // functor for operator<
private:

public:

    less()
        {
        }
    };

        // CLASS TEMPLATE _Map_alloc
template<class _Kty,
    class _Ty,
    class _Alloc = allocator<pair<const _Kty, _Ty>>>
    class _Map_alloc
    { // base class for map to hold allocator
public:
    using _Alty = _Alloc;

    using key_type = _Kty;
    using mapped_type = _Ty;
    using size_type = _NSTD size_t;

private:
    _Alty _AL;

public:

    _Map_alloc()
        {
        this->_Moveal(_Alloc());
        }

    _Map_alloc(const _Alty& _Al)
        {
        this->_Moveal(_Al);
        }

    ~_Map_alloc()
        {
        }

    void _Moveal(const _Alty& _Al)
        {
        this->_AL = _Al;
        }

    _Alty _Getal() const
        {
        return this->_AL;
        }

    };

        // CLASS TEMPLATE map
template<class _Kty,
    class _Ty,
    class _Pr = less<_Kty>,
    class _Alloc = allocator<pair<const _Kty, _Ty>>>
    class map
        : _Map_alloc<_Kty, _Ty, _Alloc>
    { // ordered collection of {key, mapped} values, unique keys
private:
    using _Mybase = _Map_alloc<_Kty, _Ty, _Alloc>;
    using _Alty = typename _Mybase::_Alty;

    using key_type = typename _Mybase::key_type;
    using mapped_type = typename _Mybase::mapped_type;
    using size_type = typename _Mybase::size_type;
    using key_compare = _Pr;


    size_type _MY_SIZE;

public:

    map() noexcept
        : _Mybase()
        {
        }

    map(initializer_list<pair<key_type, mapped_type>> _Ilist) noexcept
        : _Mybase()
        {
        }

    map(initializer_list<pair<key_type, mapped_type>> _Ilist, const _Alty& _Al) noexcept
        : _Mybase(_Al)
        {
        }

    explicit map(const _Alty& _Al) noexcept
        : _Mybase(_Al)
        {
        }

    ~map()
        {
        }

// access methods

    size_type _Mysize() const
        {
        return this->_MY_SIZE;
        }

// operators

    mapped_type operator[](key_type _Key) const
        {
        return this->value(_Key);
        }

// "private"

// public methods

    mapped_type value(key_type _Key) const
        {
        mapped_type _Val;
        return _Val;
        }

    key_type * keys() const
        {
        key_type _Keys[this->size()];
        return _Keys;
        }

    size_type size() const
        {
        return this->_Mysize();
        }

    void insert(key_type _Key, mapped_type _Value)
        {
        }

    };

#endif // _NSMAP_

/*
 * Copyright (c) by R. Wilson. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V1.0:0003 */
