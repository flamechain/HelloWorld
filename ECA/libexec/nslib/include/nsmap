// NSLib map header
#pragma once
#ifndef _NSMAP_
#define _NSMAP_

#include <xnsdef>
#include <xnsmem0>
#include <xnsinit_list>

using _NSTD allocator;
using _NSTD initializer_list;

        // CLASS TEMPLATE pair
template<class _Kty,
    class _Ty>
    class pair
    { // store a pair of values
private:
    using key_type = _Kty;
    using mapped_type = _Ty;


    key_type _MY_KEY;
    mapped_type _MY_VALUE;

public:

    pair() noexcept
        {
        }

    pair(key_type _Key, mapped_type _Val) noexcept
        {
        this->_MY_KEY = _Key;
        this->_MY_VALUE = _Val;
        }

    ~pair()
        {
        }

// public methods

    key_type key() const
        {
        return this->_MY_KEY;
        }

    mapped_type value() const
        {
        return this->_MY_VALUE;
        }

    };

        // CLASS TEMPLATE make_pair
template<class _Kty,
    class _Ty>
    pair<_Kty, _Ty> make_pair(_Kty _Key, _Ty _Val)
        {
        pair<_Kty, _Ty> _Pair (_Key, _Val);
        return _Pair;
        }

template<class _Kty,
    class _Ty>
    class _Map_iterator
    {
private:
    using pointer = pair<_Kty, _Ty> *;
    using value_type = pair<_Kty, _Ty>;
    using size_type = _NSTD size_t;


    const pointer _MY_PTR;
    size_type _MY_POS;

public:

    _Map_iterator() noexcept
        {
        }

    _Map_iterator(pointer _Ptr) noexcept
        : _MY_PTR(_Ptr)
        {
        this->_MY_POS = 0;
        }

    _Map_iterator(const _Map_iterator& _Mapit) noexcept
        : _MY_PTR(_Mapit._Myptr())
        {
        this->_MY_POS = _Mapit._Mypos();
        }

    ~_Map_iterator()
        {
        }

// access methods

    pointer _Myptr() const
        {
        return this->_MY_PTR;
        }

    size_type _Mypos() const
        {
        return this->_MY_POS;
        }

// operators

    int operator==(const _Map_iterator& _Right) const
        {
        return this->comparePtr(_Right);
        }

    int operator!=(const _Map_iterator& _Right) const
        {
        if (this->comparePtr(_Right))
            {
            return 0;
            }
        
        return 1;
        }

    value_type operator*() const
        {
        return this->_Myptr()[this->_Mypos()];
        }

    void operator++()
        {
        this->next();
        }

// public methods

    int comparePtr(const _Map_iterator& _Right) const
        {
        auto _Myloc = this->_Myptr() + this->_Mypos()*sizeof(value_type);
        auto _Right_loc = _Right._Myptr() + _Right._Mypos()*sizeof(value_type);

        if (_Myloc == _Right_loc)
            {
            return 1;
            }

        return 0;
        }

    int comparePos(const _Map_iterator& _Right) const
        {
        if (this->_Mypos() == _Right._Mypos())
            {
            return 1;
            }

        return 0;
        }

    void position(size_type _Pos)
        {
        this->_MY_POS = _Pos;
        }

    void next()
        {
        this->_MY_POS++;
        }

    };

        // CLASS TEMPLATE less
template<class _Ty>
    class less
    { // functor for operator<
private:

public:

    less()
        {
        }
    };

        // CLASS TEMPLATE _Map_alloc
template<class _Kty,
    class _Ty,
    class _Alloc = allocator<pair<const _Kty, _Ty>>>
    class _Map_alloc
    { // base class for map to hold allocator
public:
    using _Alty = _Alloc;

    using key_type = _Kty;
    using mapped_type = _Ty;
    using size_type = _NSTD size_t;
    using iterator = _Map_iterator<_Kty, _Ty>;
    using pointer = pair<_Kty, _Ty> *;

private:
    _Alty _AL;

public:

    _Map_alloc()
        {
        this->_Moveal(_Alloc());
        }

    _Map_alloc(const _Alty& _Al)
        {
        this->_Moveal(_Al);
        }

    ~_Map_alloc()
        {
        }

    void _Moveal(const _Alty& _Al)
        {
        this->_AL = _Al;
        }

    _Alty _Getal() const
        {
        return this->_AL;
        }

    };

        // CLASS TEMPLATE map
template<class _Kty,
    class _Ty,
    class _Pr = less<_Kty>,
    class _Alloc = allocator<pair<const _Kty, _Ty>>>
    class map
        : _Map_alloc<_Kty, _Ty, _Alloc>
    { // ordered collection of {key, mapped} values, unique keys
private:
    using _Mybase = _Map_alloc<_Kty, _Ty, _Alloc>;
    using _Alty = typename _Mybase::_Alty;

    using key_type = typename _Mybase::key_type;
    using mapped_type = typename _Mybase::mapped_type;
    using size_type = typename _Mybase::size_type;
    using iterator = typename _Mybase::iterator;
    using pointer = typename _Mybase::pointer;
    using key_compare = _Pr;


    pointer _MY_PTR;
    size_type _MY_SIZE;

public:

    map() noexcept
        : _Mybase()
        {
        }

    map(initializer_list<pair<key_type, mapped_type>> _Ilist) noexcept
        : _Mybase()
        {
        }

    map(initializer_list<pair<key_type, mapped_type>> _Ilist, const _Alty& _Al) noexcept
        : _Mybase(_Al)
        {
        }

    explicit map(const _Alty& _Al) noexcept
        : _Mybase(_Al)
        {
        }

    ~map()
        {
        }

// access methods

    size_type _Mysize() const
        {
        return this->_MY_SIZE;
        }

    pointer _Myptr() const
        {
        return this->_MY_PTR;
        }

// operators

    mapped_type operator[](key_type _Key) const
        {
        return this->value(_Key);
        }

// "private"

// public methods

    mapped_type value(key_type _Key) const
        {
        mapped_type _Val;
        return _Val;
        }

    key_type * keys() const
        {
        key_type _Keys_temp[this->size()];
        key_type * _Keys = _Keys_temp;
        return _Keys;
        }

    size_type size() const
        {
        return this->_Mysize();
        }

    void insert(key_type _Key, mapped_type _Value)
        {
        }

    iterator begin() const
        {
        iterator _It (this->_Myptr());
        return _It;
        }

    iterator end() const
        {
        iterator _It (this->_Myptr());
        _It.position(this->_Mysize());
        return _It;
        }

    };

#endif // _NSMAP_

/*
 * Copyright (c) by R. Wilson. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V1.0:0004 */
