// NSLib vector header
#pragma once
#ifndef _NSVECTOR_
#define _NSVECTOR_

#include <xnsdef>
#include <xnsmem0>
#include <xnsinit_list>

#include <stdio.h>

using _NSTD initializer_list;
using _NSTD allocator;

template<class _Ty,
    class _Alloc = allocator<_Ty>>
    class _Vector_alloc
    {
public:
    using _Alty = _Alloc;

    using value_type = _Ty;
    using pointer = _Ty *;
    using const_pointer = const _Ty * const;
    using size_type = _NSTD size_t;

private:
    _Alty _AL;

public:

    _Vector_alloc()
        {
        this->_AL = _Alloc();
        }

    _Vector_alloc(const _Alty& _Al)
        {
        this->_Moveal(_Al);
        }

    ~_Vector_alloc()
        {
        }

    void _Moveal(const _Alty& _Al)
        {
        this->_AL = _Al;
        }

    _Alty _Getal() const
        {
        return this->_AL;
        }

    };

template<class _Ty,
    class _Alloc = allocator<_Ty>>
    class vector
        : public _Vector_alloc<_Ty, _Alloc>
    {
private:
    using _Mybase = _Vector_alloc<_Ty, _Alloc>;
    using _Alty = typename _Mybase::_Alty;

    using value_type = typename _Mybase::value_type;
    using pointer = typename _Mybase::pointer;
    using const_pointer = typename _Mybase::const_pointer;
    using size_type = typename _Mybase::size_type;

    using reference = value_type&;
    using const_reference = const value_type&;


    value_type _Null_value = value_type();

    pointer _MY_PTR;
    size_type _MY_SIZE;
    size_type _MY_RES;

public:

    vector() noexcept
        : _Mybase()
        {
        this->_Tidy_init();
        }

    vector(initializer_list<value_type> _Ilist) noexcept
        : _Mybase()
        {
        this->_Construct_contents(_Ilist.begin(), _Ilist.size());
        }

    vector(initializer_list<value_type> _Ilist, const _Alty& _Al) noexcept
        : _Mybase(_Al)
        {
        this->_Construct_contents(_Ilist.begin(), _Ilist.size());
        }

    vector(const vector& _Right) noexcept
        : _Mybase()
        {
        this->_Construct_contents(_Right);
        }

    vector(const vector& _Right, const _Alty& _Al) noexcept
        : _Mybase(_Al)
        {
        this->_Construct_contents(_Right);
        }

    explicit vector(const _Alty& _Al) noexcept
        : _Mybase(_Al)
        {
        }

    ~vector()
        {
        _Alty _Al = this->_Getal();
        _Al.deallocate(this->_Myptr(), this->_Myres());
        }

    void operator=(const vector& _Right)
        {
        if (this != _NSTD addressof(_Right))
            {
            this->_Tidy_deallocate();
            this->_Moveal(_Right._Getal());
            this->_Construct_contents(_Right);
            }
        }

// "private" (only used by vector even if another instance)

    void _Tidy_init()
        {
        _Alty _Al = this->_Getal();
        this->_MY_PTR = _Al.allocate(10); // buffer
        this->_MY_SIZE = 0;
        this->_MY_RES = 10;
        }

    void _Tidy_deallocate()
        {
        if (this->_Myres() > 0)
            {
            _Alty _Al = this->_Getal();
            _Al.deallocate(this->_Myptr(), this->_Myres());
            }
        }

    void _Construct_contents(const vector& _Right)
        {
        this->_Construct_contents(_Right._Myptr(), _Right._Mysize());
        }

    void _Construct_contents(pointer _Start, size_type _Size)
        {
        const_pointer _Start_c = _Start;
        this->_Construct_contents(_Start_c, _Size);
        }

    void _Construct_contents(const_pointer _Start, size_type _Size)
        {
        this->_Tidy_init();

        if (this->_Myres() > _Size + 1)
            {
            _NSTD copyinto(this->_Myptr(), _Start, _Size);
            this->_MY_SIZE = _Size;
            return;
            }

        const size_type _New_capacity = _Size;
        _Alty _Al = this->_Getal();
        pointer _New_array = _Al.allocate(_New_capacity+1); // issue without this (very weird bug I have no idea how to solve, issue with copying elements, res becomes huge value, then crash)
        _Al.deallocate(this->_Myptr(), this->_Myres());
        this->_MY_PTR = _New_array;

        _NSTD copyinto(this->_Myptr(), _Start, _Size);
        this->_MY_SIZE = _New_capacity;
        this->_MY_RES = _New_capacity + 1;
        }

// access methods

    pointer _Myptr() const
        {
        return this->_MY_PTR;
        }

    size_type _Mysize() const
        {
        return this->_MY_SIZE;
        }

    size_type _Myres() const
        {
        return this->_MY_RES;
        }

// operators

    value_type operator[](size_type _Index) const
        {
        return this->index(_Index); // could also use this->_Myptr()[_Index] here
        }

    vector<_Ty> operator+(vector<_Ty> _Right) const
        {
        vector<_Ty> _Total;

        for (size_type i=0; i<this->_Mysize(); i++)
            {
            _Total.push_back(this->_Myptr()[i]);
            }

        for (size_type i=0; i<_Right._Mysize(); i++)
            {
            _Total.push_back(_Right._Myptr()[i]);
            }

        return _Total;
        }

// public methods

    inline void append(const_reference _Value) { this->push_back(_Value); }
    void push_back(const_reference _Value)
        {
        if (this->_Myres() > this->_Mysize() + 1)
            {
            this->_Myptr()[this->_Mysize()] = _Value;
            this->_MY_SIZE++;
            return;
            }

        _Alty _Al = this->_Getal();
        const size_type _New_capacity = this->_Mysize() + 10;
        pointer _New_array = _Al.allocate(_New_capacity+1);
        _NSTD copyinto(_New_array, this->_Myptr(), this->_Mysize());

        _Al.deallocate(this->_Myptr(), this->_Myres());
        this->_MY_PTR = _New_array;
        this->_Myptr()[this->_Mysize()] = _Value;

        this->_MY_SIZE++;
        this->_MY_RES = _New_capacity + 1;
        }

    inline void pop_back() { this->pop(); }
    void pop()
        {
        this->pop(this->_Mysize()-1);
        }

    void pop(size_type _Index)
        {
        _Alty _Al = this->_Getal();
        pointer _New_array = _Al.allocate(this->_Myres()+1);

        size_type j, in;
        for (j=0, in=0; j<this->_Mysize(); j++, in++)
            {
            if (j == _Index)
                {
                in--;
                continue;
                }

            _New_array[in] = this->_Myptr()[j];
            }

        _Al.deallocate(this->_Myptr(), this->_Myres());
        this->_MY_PTR = _New_array;
        this->_MY_SIZE--;
        }

    value_type index(long long _Index) const
        {
        if (_Index < 0)
            {
            _Index += this->_Mysize();
            }

        if (_Index < this->_Mysize())
            {
            return this->_Myptr()[_Index];
            }

        return _Null_value;
        }

    inline size_type count() const { return this->size(); }
    size_type size() const
        {
        return this->_Mysize();
        }

    pointer to_array() const
        {
        _Alty _Al = this->_Getal();
        pointer _Copy = _Al.allocate(this->_Mysize()+1);

        for (size_type i=0; i<this->_Mysize(); i++)
            {
            _Copy[i] = this->_Myptr()[i];
            }

        return _Copy;
        }

    };

#endif
